
package kmeanscluster;


//Aim:To implement Kmeans clustering algorithm for 1 dimensional feature space using a single band. 
// The code gets executed until the cluster means for a given iteration becomes equal to that of prior iteration.
//Program
// Importing the libraries/classes required for the K means classification
import java.util.*;
import org.gdal.gdal.Driver;
import org.gdal.gdal.Dataset;
import org.gdal.gdal.gdal;
import org.gdal.gdalconst.gdalconstConstants;
import org.gdal.gdal.Band;
import org.gdal.osr.SpatialReference;
import org.gdal.gdalconst.gdalconst;
import java.nio.ByteBuffer;
import java.math.*;
class KmeansCluster
{
static int count1,count2,count3;
static int d[];
static int k[][];
static int tempk[][];
static double m[];
static double diff[];
static int n,p;

static int cal_diff(int a) // This method will determine the cluster in which an element go at a particular step.
{

for(int i=0;i<p;++i)
{
if(a>m[i])
diff[i]=Math.abs(a-m[i]);
else
diff[i]=Math.abs(m[i]-a);
}
int val=0;
double temp=diff[0];
for(int i=0;i<p;++i)
{
if(diff[i]<temp)
{
temp=diff[i];
val=i;
}
}//end of for loop
return val;
}

static void cal_mean() // This method will determine intermediate mean values for each iteration
{
for(int i=0;i<p;++i)
m[i]=0; // initializing means to 0
int cnt=0;
for(int i=0;i<p;++i)
{
cnt=0;
for(int j=0;j<n-1;++j)
{
if(k[i][j]!=-1)
{
m[i]+=k[i][j];
++cnt;
}}
m[i]=m[i]/cnt;
}
}

static int check1() // This checks if previous set of cluster means  (ie. tempk) and current set of cluster means (k) are same.Used as terminating case.
{
for(int i=0;i<p;++i)
for(int j=0;j<n;++j)
if(tempk[i][j]!=k[i][j])
{
return 0;
}
return 1;
}
// Main fuction used to perform K-MEANS CLASSIFICATION
public static void main(String args[])
{
    gdal.AllRegister();
    
    Scanner scr=new Scanner(System.in);
    System.out.println("K-Means clustering algorithm for 1 dimensional space");
    // Specification of path for input file
    System.out.println("Enter the path for the input image");
    String path_image=scr.nextLine();
    Dataset image=gdal.Open(path_image);
             int width=image.GetRasterXSize();
             int height=image.GetRasterYSize();
             int numBands=image.GetRasterCount();
             System.out.println("Number of bands in image are  "+numBands);
             System.out.println("Which band would you like to use for K-means clustering?");
             int band_num=scr.nextInt();

n=width*height;
d=new int[n];
Band b1= image.GetRasterBand(band_num);
b1.ReadRaster(0, 0, width, height, d);
// Specification of the number of clusters to be used for classification
System.out.println("Enter the number of clusters: ");
p=scr.nextInt();
/* Initialising arrays */
k=new int[p][n];
tempk=new int[p][n];
m=new double[p];
diff=new double[p];
/* Initializing m */
for(int i=0;i<p;++i)
m[i]=d[i];

int temp=0;
int flag=0;
do
{
for(int i=0;i<p;++i)
for(int j=0;j<n;++j)
{
k[i][j]=-1;
}
for(int i=0;i<n;++i) // for loop will cal cal_diff(int) for every element.
{
temp=cal_diff(d[i]);
if(temp==0)
k[temp][count1++]=d[i];
else
if(temp==1)
k[temp][count2++]=d[i];
else
if(temp==2)
k[temp][count3++]=d[i]; 
}
cal_mean(); // call to method which will calculate mean at this step.
flag=check1(); // check if terminating condition is satisfied.
if(flag!=1)
/*Take backup of k in tempk so that you can check for equivalence in next step*/
for(int i=0;i<p;++i)
for(int j=0;j<n;++j)
tempk[i][j]=k[i][j];

System.out.println("\n\nAt this step");
System.out.println("\nValue of clusters");
for(int i=0;i<p;++i)
{
System.out.print("K"+(i+1)+"{ ");
for(int j=0;k[i][j]!=-1 && j<n-1;++j)
System.out.print(k[i][j]+" ");
System.out.println("}");
}//end of for loop
System.out.println("\nValue of m ");
for(int i=0;i<p;++i)
System.out.print("m"+(i+1)+"="+m[i]+"  ");

count1=0;count2=0;count3=0;
}
while(flag==0);
//To print the output clusters
System.out.println("\n\n\nThe Final Clusters By Kmeans are as follows: ");
for(int i=0;i<p;++i)
{
System.out.print("K"+(i+1)+"{ ");
for(int j=0;k[i][j]!=-1 && j<n-1;++j)
System.out.print(k[i][j]+" ");
System.out.println("}");
}
}
}
